---
description: 
globs: 
alwaysApply: false
---
# Principes d'Architecture

Ce document définit les principes d'architecture à suivre pour tous les projets. Chaque projet doit être structuré selon ces règles pour garantir cohérence, maintenabilité et évolutivité.

## Structure Générale

Chaque projet doit être organisé selon une architecture modulaire avec les composants suivants clairement séparés :

```mermaid
graph TD
    A[Client/Frontend] --> B[API Gateway]
    B --> C[Services Backend]
    B --> D[AAA Service]
    C --> E[External Services]
    F[Interceptors] --> B
    G[Tests] --> A
    G --> B
    G --> C
    G --> D
```

## Composants Obligatoires

### 1. AAA (Authentication, Authorization, Account)

- **Authentication** : Système de gestion des identités et d'authentification
  - Support multi-méthodes (JWT, OAuth2, OIDC)
  - Gestion de session sécurisée
  - Protection contre les attaques courantes (CSRF, XSS)

- **Authorization** : Système de contrôle d'accès
  - RBAC (Role-Based Access Control)
  - ABAC (Attribute-Based Access Control) pour les cas complexes
  - Vérification des permissions à tous les niveaux (API, service, données)

- **Accounting** : Gestion des comptes utilisateurs
  - Profils utilisateurs avec données personnalisables
  - Self-service (inscription, récupération de mot de passe)
  - Audit trail des activités utilisateur

### 2. Interceptors

- **Logging** : Capture et enregistrement des événements
  - Logs structurés (JSON)
  - Niveaux de log configurables
  - Corrélation des requêtes (request ID)
  - Rotation et rétention des logs

- **Error Handling** : Gestion centralisée des erreurs
  - Normalisation des erreurs
  - Messages d'erreur utilisateur vs. logs techniques
  - Circuit breakers pour les services externes
  - Retry policies configurables

- **Monitoring** : Surveillance des performances
  - Métriques système et applicatives
  - Health checks
  - Alerting

### 3. Tests

- **Tests Unitaires** : Couverture minimale de 80%
  - Tests isolés avec mocks/stubs
  - Exécution rapide (<1s par test)

- **Tests d'Intégration** : Validation des interactions entre composants
  - Tests avec dépendances réelles ou conteneurisées
  - Validation des contrats d'API

- **Tests End-to-End** : Validation des scénarios utilisateur
  - Tests automatisés de l'UI
  - Tests de performance et charge

- **Tests de Sécurité** : Validation des contrôles de sécurité
  - SAST (Static Application Security Testing)
  - DAST (Dynamic Application Security Testing)
  - Analyse de dépendances

- **Tests fontionnels** : S'assurer que ça fonctionne
  - Lorque tu dépoie un backend et/ou un frontend, il faut que tu généres ce qu'il faut pour les tester en local avec ce qu'il faut avec un maximum de log et debug.   

### 4. Frontend

- **Architecture** : Basée sur des composants réutilisables
  - Design System documenté
  - State management centralisé
  - Responsive design

- **Performance** : Optimisation pour l'expérience utilisateur
  - Lazy loading
  - Code splitting
  - Optimisation des assets

- **Accessibilité** : Conformité WCAG AA minimum
  - Support des lecteurs d'écran
  - Navigation au clavier
  - Contraste et taille de texte adaptés

### 5. Backend

- **API** : RESTful ou GraphQL avec documentation OpenAPI/Swagger
  - Versioning d'API
  - Rate limiting
  - Pagination standardisée

- **Services** : Architecture microservices ou modulaire
  - Séparation claire des responsabilités
  - Communication asynchrone quand approprié
  - Idempotence des opérations critiques

- **Données** : Modèles et accès aux données
  - Migrations automatisées
  - Validation des données
  - Caching stratégique

### 6. Intégrations Externes

- **API Clients** : Communication avec services externes
  - Retry logic
  - Circuit breakers
  - Timeout configuration
  - Mocks pour le développement et les tests

- **Webhooks** : Réception d'événements externes
  - Validation de signature
  - Idempotence
  - Queue pour traitement asynchrone

- **File d'attente** : Traitement asynchrone
  - Dead letter queues
  - Monitoring de la profondeur des queues
  - Retry policies

## Standards Techniques

### Sécurité

- Chiffrement en transit (TLS 1.3+)
- Chiffrement au repos pour les données sensibles
- Audit régulier des dépendances
- Principe du moindre privilège

### Observabilité

- Logs centralisés
- Distributed tracing
- Métriques applicatives
- Dashboards de monitoring

### Infrastructure as Code

- Définition déclarative de l'infrastructure
- Environnements reproductibles
- CI/CD automatisé

### Documentation

- Documentation technique auto-générée
- Documentation utilisateur
- Diagrammes d'architecture
- ADRs (Architecture Decision Records)

## Processus de Revue

Chaque projet doit passer par une revue d'architecture qui vérifie la conformité à ces principes avant de passer en production.


### Cohérence
- Il est impératif de garantir une cohérence entre le backend et le frontend. Je m'explique, lorsque par exemple, tu utilises mongoDB en backend, il faut s'assurer que coté frontend tu réalises bien des appels mongoDB et non SQLalchemy ou autre.
- Il faut donc s'assurer en relisant les codes pour etre cohérent
- Je veux que tu pilotes le backend et le frontend via un meme script
- Je veux que tu traces et documentes toutes tes action dans un répertoire docs à la racine du projet. Toutes les actions doivent y etre notifiés et le code doit etre complétement décris.
- Tu te refereras à la documentations (docs) à chaque nouveau prompt afin de te reperer et savoir ce qui a été fait
- Je veux que pour chaque projet tu respectes la structure suivante : à la racine du projet les répertoires shared (pour tout ce qui est commun), docs pour la documentation, backend pour le backend, frontend pour le frontend, scripts contenant tous les scripts relatifs au déploiement de l'application, logs pour les logs applicatifs.
- Aucun fichier ne doit se trouver sans un sous dossier. Il doit forcement etre dans un répertoire cité ci dessus.
- Ne pas faire de mode hors ligne





